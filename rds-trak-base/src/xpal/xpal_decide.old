%
%   xpal_decide.w -- determine processing status and sorter lane assignment
%
%   Author: Adam Marshall
%
%   History:
%      2015-05-05 -AHM- init, for Sunstar print/apply
%
%
%         C O N F I D E N T I A L
%
%     This information is confidential and should not be disclosed to
%     anyone who does not have a signed non-disclosure agreement on file
%     with Numina Systems Corporation.  
%
%
%
%
%
%     (C) Copyright 2015 Numina Group, Inc.  All Rights Reserved.
%
%
%

% --- helpful macros ---
\def\dot{\item{ $\bullet$}}
\def\boxit#1#2{\vbox{\hrule\hbox{\vrule\kern#1\vbox{\kern#1#2\kern#1}%
   \kern#1\vrule}\hrule}}
\def\today{\ifcase\month\or
   January\or February\or March\or April\or May\or June\or
   July\or August\or September\or October\or November\or December\or\fi
   \space\number\day, \number\year}

% --- title block ---
\def\title{decide}
\def\topofcontents{\null\smallskip
\centerline{\titlefont \title}
\smallskip
This program decides the processing status of a box and assigns the
physical lane for sortation.

% --- confidentiality statement ---
\bigskip
\centerline{\boxit{10pt}{\hsize 4in
\bigskip
\centerline{\bf CONFIDENTIAL}
\smallskip
This material is confidential.  
It must not be disclosed to any person
who does not have a current signed non-disclosure form on file with Numina
Systems Corporation.
It must only be disseminated on a need-to-know basis.
It must be stored in a secure location. 
It must not be left out unattended.  
It must not be copied.  
It must be destroyed by burning or shredding. 
\smallskip
}}

% --- author and version ---
\bigskip
\centerline{Author: Adam Marshall}
\centerline{Printing Date: \today}
\centerline{Control Revision: $ $Revision: 1.10 $ $}
\centerline{Control Date: $ $Date: 2022/11/10 00:24:58 $ $}
}

% --- copyright notice ---
\def\botofcontents{\vfill
\centerline{\copyright 2015 Numina Group, Inc.  All Rights Reserved.}
}

@* Overview. 
This program decides the processing status of a box and assigns the
physical lane for sortation.

@c
static char rcsid[] = "$Id: xpal_decide.w,v 1.10 2022/11/10 00:24:58 rds Exp $";
@<Includes@>@;
@<Defines@>@;
@<Globals@>@;
@<Prototypes@>@;
@<Functions@>@;


int main( int argc, char *argv[] ) {
   int box;
   int seq;

   @<initialize@>@;
   @<process carton@>@;

   exit( EXIT_SUCCESS );
}


@ Included files.
@<Includes@>+=
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>  // for gettimeofday()

#include <app.h>
#include <rds_ctr.h>
#include <rds_sql.h>
#include <rds_trak.h>
#include <rds_trn.h>
#include <rds_util.h>


@ Definitions.
@<Defines@>+=
#define BUF_LEN          32  // length of small statically allocated strings
#define MSG_LEN         256  // length of longer message strings
#define CODE_SUCCESS      1  // status code for success
#define CODE_ERROR       -1  // status code for unspecified error
#define CODE_LOST       -99  // status code for lost box


@ Global status variables.
@<Globals@>+=
char area[ BUF_LEN + 1 ];
char name[ BUF_LEN + 1 ];


@ Initialization.
@<initialize@>+=
{
   if (argc != 2) {
      printf( "usage: %s <box>\n", argv[0] );
      exit( EXIT_FAILURE );
   }

   strcpy( area, "xpal" );
   sprintf( name, "x-decide" );
   trn_register( name );

   box = atoi( argv[1] );
   if (box <= 0 || box > 999) {
      Alert( "invalid box [%d]", box );
      util_zone_release( name );
      exit( EXIT_SUCCESS );
   }

   seq = util_box_get_int( box, "seq" );
   if (seq <= 0) {
      Alert( "%03d: invalid carton [%d]", box, seq );
      util_zone_release( name );
      exit( EXIT_SUCCESS );
   }

   Trace( "%03d: decide carton [%d]", box, seq );
}


@ Process the carton.
@<process carton@>=
{
   struct timeval start_time;
   int code;

   @<begin processing@>@;

   @<determine status@>@;
   @<assign lane@>@;
   @<update carton@>@;

   @<finish processing@>@;
}


@ Begin processing: initialization, etc.
@<begin processing@>=
{
   gettimeofday( &start_time, NULL );

   code = CODE_ERROR;
}


@ Finish processing.
@<finish processing@>=
{
   sql_query(
         "UPDATE `%sCartons` SET "
         "decideStamp = NOW() "
         "WHERE seq = %d",
         area, seq );

   Inform( "%03d: processing complete for carton [%d], took %.3f sec",
         box, seq, util_get_elapsed( start_time ) );

   // mark lost boxes
   for ( ; ; usleep( 10 ) ) {
      int lost_seq;
      char *val = sql_getvalue(
            "SELECT seq FROM `%sCartons` "
            "WHERE seq < %d "
            "AND status = 0 "
            "ORDER BY seq LIMIT 1",
            area, seq );
      if (val == NULL || strlen( val ) == 0)
         break;

      lost_seq = atoi( val );
      Alert( "carton [%d] detected as lost", lost_seq );
      sql_query(
            "UPDATE `%sCartons` SET "
            "status = %d, "
            "description = 'lost in tracking', "
            "decideStamp = NOW() "
            "WHERE seq = %d",
            area, CODE_LOST, lost_seq );
   }

   util_box_clear( box );
   util_zone_release( name );
}


@ Determine the carton status.
@<determine status@>=
{
   char result_name[ BUF_LEN + 1 ];
   char result_status[ BUF_LEN + 1 ];
   char result_value[ BUF_LEN + 1 ];
   char result_desc[ MSG_LEN + 1 ];

   code = get_carton_result( seq, result_name, result_status,
         result_value, result_desc );

   ctr_incr( "/%s", area );
   if (code >= 0) {
      Trace( "%03d: %s for [%d] (code %d)", box, result_desc, seq, code );
      ctr_incr( "/%s/pass", area );
      ctr_incr( "/%s/pass/%s", area, result_name );
   } else {
      Alert( "%03d: %s for [%d] (code %d)", box, result_desc, seq, code );
      ctr_incr( "/%s/fail", area );
      ctr_incr( "/%s/fail/%s", area, result_name );
      ctr_incr( "/%s/fail/%s/%s", area, result_name, result_status );
      if (strlen( result_value ) > 0)
         ctr_incr( "/%s/fail/%s/%s/%s",
               area, result_name, result_status, result_value );
   }

   // update the carton
   app_update_description( area, seq, area, "%s at print/apply", result_desc );
   sql_query(
         "UPDATE `%sCartons` SET "
         "status = %d "
         "WHERE seq = %d",
         area, code, seq );
}


@ Determine and assign the physical lane for sortation.
@<assign lane@>=
{
   int physical;
   char logical[ BUF_LEN + 1 ];
   char description[ MSG_LEN + 1 ];

   strcpy( logical, "exception" );
   if (code > 0) {
      char *val = util_carton_get( area, seq, "lane" );
      if (val != NULL && strlen( val ) > 0) {
         strncpy( logical, val, BUF_LEN );
         logical[ BUF_LEN ] = '\0';
      } else {
         strcpy( logical, "success" );
      }
   }

   physical = app_get_physical_code( area, logical );
   if (physical < 0) {
      strcpy( logical, "exception" );
      physical = app_get_physical_code( area, logical );
   }

   bx_setdata( box, physical );

   Trace( "%03d: carton [%d] sorted to %s (%d) for [%s]",
         box, seq, description, physical, logical );
  app_update_description( area, seq, "xpal", "sorted to %s", description );

  ctr_incr( "/%s-sort", area );
  ctr_incr( "/%s-sort/%s", area, logical );
}


@ Determine the processing status for a carton.
@<Functions@>+=
int get_carton_result( int seq, char result_name[], char result_status[],
      char result_value[], char description[] ) {
   int err, code;

   strcpy( result_name, "" );
   strcpy( result_status, "" );
   strcpy( result_value, "" );
   strcpy( description, "" );

   err = sql_query(
         "SELECT name, status, value FROM cartonStatus "
         "WHERE seq = %d "
         "AND status IN ('pending', 'failed') "
         "ORDER BY ordinal LIMIT 1",
         seq );

   if (err) {
      strcpy( result_name, "unknown" );
      strcpy( description, "unable to determine carton status" );
      Alert( "sql error (%d) determining carton status for [%d]",
            err, seq );
      return CODE_ERROR;
   }

   if (sql_rowcount() == 0) {
      strcpy( result_name, "success" );
      strcpy( description, "carton processed successfully" );
      return CODE_SUCCESS;
   }
   strncpy( result_name, sql_get( 0, 0 ), BUF_LEN );
   result_name[ BUF_LEN ] = '\0';
   strncpy( result_status, sql_get( 0, 1 ), BUF_LEN );
   result_status[ BUF_LEN ] = '\0';
   strncpy( result_value, sql_get( 0, 2 ), BUF_LEN );
   result_value[ BUF_LEN ] = '\0';
   Inform( "carton [%d] has result [%s-%s], value = [%s]",
         seq, result_name, result_status, result_value );

   // look up the result description
   err = sql_query(
         "SELECT code, result FROM results "
         "WHERE name = '%s' "
         "AND status = '%s' "
         "AND value = '%s'",
         result_name, result_status, result_value );
   if (!err && sql_rowcount() == 1) {
      code = atoi( sql_get( 0, 0 ) );
      strcpy( description, sql_get( 0, 1 ) );
   } else {
      code = CODE_ERROR;
      if (strlen( result_value ) > 0)
         sprintf( description, "%s %s, value = %s",
               result_name, result_status, result_value );
      else
         sprintf( description, "%s %s", result_name, result_status );
   }

   return code;
}
@ Prototype the function.
@<Prototypes@>+=
int get_carton_result( int seq, char result_name[], char result_status[],
      char result_value[], char description[] );


@ Update processing status.
@<update carton@>=
{
   char container_type[ BUF_LEN + 1 ];
   char *val = util_carton_get( area, seq, "containerType" );
   if (val != NULL && strlen( val ) > 0) {
      strncpy( container_type, val, BUF_LEN );
      container_type[ BUF_LEN ] = '\0';
   } else {
      strcpy( container_type, "" );
   }

   if (strcmp(container_type, "carton") == 0){
      if (was_labeling_attempted(seq)){
         int carton_seq = atoi( util_carton_get( area, seq, "containerSeq") );
         sql_query(
            "REPLACE INTO rdsCartonData "
            "SET cartonSeq = %d, "
            "dataType = '%s', "
            "dataValue = '%d'",
            carton_seq, "statusCode", code == 1 ? 0 : -code);
         
         sql_query(
            "INSERT INTO rdsUploadQueue "
            "SET uploadType = 'labelConfirmation', "
            "data = '%d'",
            carton_seq);

         if (code == 1){
            sql_query(
               "UPDATE rdsCartons SET labelStamp = NOW() WHERE cartonSeq = %d", carton_seq);
         }
      }
   }
}

@ Determine if a subsystem result is complete.
@<Functions@>+=
int was_labeling_attempted( int seq) {
   char *val = sql_getvalue(
         "SELECT status FROM cartonStatus "
         "WHERE seq = %d "
         "AND name = 'label'",
         seq );
   return (val != NULL && ( (strcmp( val, "complete" ) == 0) || (strcmp(val, "failed") == 0) ) );
}

@ Prototype the function.
@<Prototypes@>+=
int was_labeling_attempted( int seq );


@* Index.
