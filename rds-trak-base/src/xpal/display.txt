%   display.w -- thin term client 
%
%   Author: Mark Woodworth 
%
%   History:
%      2018-08-15 -MRW- init
%
%
%         C O N F I D E N T I A L
%
%     This information is confidential and should not be disclosed to
%     anyone who does not have a signed non-disclosure agreement on file
%     with Numina Systems Corporation.  
%
%
%
%
%
%     (C) Copyright 2018 Numina Systems Corporation.  All Rights Reserved.
%
%
%

% --- helpful macros ---
\def\dot{\item{ $\bullet$}}
\def\boxit#1#2{\vbox{\hrule\hbox{\vrule\kern#1\vbox{\kern#1#2\kern#1}%
   \kern#1\vrule}\hrule}}
\def\today{\ifcase\month\or
   January\or February\or March\or April\or May\or June\or
   July\or August\or September\or October\or November\or December\or\fi
   \space\number\day, \number\year}

% --- title block ---
\def\title{Display}
\def\topofcontents{\null\smallskip
\centerline{\titlefont \title}
\smallskip
Thin term client.

% --- confidentiality statement ---
\bigskip
\centerline{\boxit{10pt}{\hsize 4in
\bigskip
\centerline{\bf CONFIDENTIAL}
\smallskip
This material is confidential.  
It must not be disclosed to any person
who does not have a current signed non-disclosure form on file with Numina
Systems Corporation.
It must only be disseminated on a need-to-know basis.
It must be stored in a secure location. 
It must not be left out unattended.  
It must not be copied.  
It must be destroyed by burning or shredding. 
\smallskip
}}

% --- author and version ---
\bigskip
\centerline{Author: Mark Woodworth}
\centerline{Printing Date: \today}
\centerline{Control Revision: $ $Revision: 1.351 $ $}
}

% --- copyright notice ---
\def\botofcontents{\vfill
\centerline{\copyright 2018 NuminaGroup, Inc.  All Rights Reserved.}
}

@* Overview. 
This is a thin terminal client.

@c
@<Defines@>@;
@<Structures@>@;
@<Includes@>@;
@<Globals@>@;
@<Prototypes@>;
@<Functions@>@;
int
main(int argc, char *argv[])
  {
  @<Initialize@>@;

  setup() ;
  while(1)
    loop() ;
  }

@ Includes.
@<Includes@>+=
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <sys/select.h>

#include <rds_trn.h>
#include <rds_net.h>
#include <rds_sql.h>
#include <rds_hist.h>

@ Initialize.
@<Initialize@>+=
  {
  if(argc<2)
    {
    fprintf(stderr,"usage: %s <station_id>\n",argv[0]) ;
    exit(1) ;
    }

  strncpy(stationName,argv[1],32) ;
  stationName[32] = '\0' ;

  trn_register(stationName) ;

  strcpy(net_ip,get_control(stationName,"ip","172.17.31.30")) ;
  net_port = atoi(get_control(stationName,"port","10000")) ;
  Inform("net ip %s port %d",net_ip,net_port) ;

  strcpy(printerID,get_control(stationName,"printer","p01")) ;
  }

@ The network parameters.
@<Globals@>+=
char net_ip[64+1] ;
int  net_port ;

@ The station parameters.
@<Globals@>+=
char stationName[32+1] ;
char operatorName[64+1] ;
char printerID[16+1] ;

@ A utility function to get control data.
@<Functions@>+=
char *
get_control(char *zone, char *name, char *otherwise)
  {
  static char value[128+1] ;
  char *v ;

  value[0] = '\0' ;
   
  v = sql_getcontrol(zone,name) ;
  if((v==NULL)||(strlen(v)==0))
    strncpy(value,otherwise,128) ;
  else
    strncpy(value,v,128) ;
  value[128] = '\0' ;

  return value ;
  }

@ Proto.
@<Prototypes@>+=
char *get_control(char *zone, char *name, char *otherwise) ;

@* Queue.

@ Structure.
@<Structures@>+=
struct q_struct 
  {
  char source ;
  int  id ;
  char type ;
  char text[Q_TEXT+1] ;
  } ;

@ Size.
@<Defines@>+=
#define Q_N (32)
#define Q_TEXT (128)

@ Storage.
@<Globals@>+=
int q_head ;
int q_tail ;
struct q_struct q[Q_N] ;

@ EnQueue.  Store a transaction in the queue.
@<Functions@>+=
int 
enqueue(char source, int id, char type, char *text)
  {
  int err = 0 ;

  q_head++ ;
  if(q_head>=Q_N)
    q_head = 0 ;

  q[q_head].source = source ;
  q[q_head].id     = id ;
  q[q_head].type   = type ;
  strncpy(q[q_head].text,text,Q_TEXT) ;
  q[q_head].text[Q_TEXT] = '\0' ;

  return err ;
  }

@ Proto.
@<Prototypes@>+=
int enqueue(char source, int id, char type, char *text) ;

@ DeQueue.
@<Functions@>+=
int
dequeue(char *source, int *id, char *type, char *text)
  {
  if(q_head==q_tail)
    return 0 ;

  q_tail++ ;
  if(q_tail>=Q_N) q_tail=0 ;

  *source = q[q_tail].source ;
  *id     = q[q_tail].id ;
  *type   = q[q_tail].type ;
  strncpy(text,q[q_tail].text,Q_TEXT) ;
  text[Q_TEXT] = '\0' ;

  return 1 ;
  }

@ Proto.
@<Prototypes@>+=
int dequeue(char *source, int *id, char *type, char *text) ;

@* Message.
@<Globals@>+=
int m ;
char msg[MSG_N+1] ;

@ Message size.
@<Defines@>+=
#define MSG_N (128)

@ Handle a new message from the remote system.
@<Functions@>+=
void
handle(char *text)
  {
  if(text[0]=='H')
    {
    handle_heartbeat(text) ;
    }
  else if(text[0]=='S')
    {
    handle_scan(text) ;
    }
  else if(text[0]=='E')
    {
    handle_entry(text) ;
    }
  else if(text[0]=='B')
    {
    handle_button(text) ;
    }
  else if(text[0]=='F')
    {
    handle_fkey(text) ;
    }
  else
    Inform("handle [%s]",text) ;

  }

@ Proto.
@<Prototypes@>+=
void handle(char *text) ;

@ Heartbeat.
@<Functions@>+=
void
handle_heartbeat(char *text)
  {
  }

@ Proto.
@<Prototypes@>+=
void handle_heartbeat(char *text) ;

@ Scan.
@<Functions@>+=
void 
handle_scan(char *text)
  {
  int id ;
  char data[256+1] ;
  char type ;
  char scan[128+1] ;
  int t,d,s ;

  Inform("scan %s",text) ;
 
  t = 0 ;

  d = 0 ;
  data[d  ] = '\0' ;
  while((text[t]!='\0') && (text[t]!='|') && (d<(256-1)))
    {
    data[d++] = text[t++] ;
    data[d  ] = '\0' ; 
    }
  id = atoi(data) ;

  if(text[t]=='|') t++ ;

  d = 0 ;
  data[d  ] = '\0' ;
  while((text[t]!='\0') && (text[t]!='|') && (d<(256-1)))
    {
    data[d++] = text[t++] ;
    data[d  ] = '\0' ;
    }

  s = 0 ;
  scan[s  ] = '\0' ;
  type = ' ' ;
  for(d=0 ; d<strlen(data) ; d+=2)
    {
    char hex[2+1] ;
    char c ;

    hex[0] = data[d+0] ;
    hex[1] = data[d+1] ;
    hex[2] = '\0' ;

    c = (char)strtol(hex,NULL,16) ;

#if 0
    if(d==0)
      type = c ;
    else
#endif
      {
      scan[s++] = c ;
      scan[s  ] ='\0' ;
      }
    } 

#if 0
  Inform("text %s id %d binhex %s type %c scan %s",
         text,id,data,type,scan) ; 
#endif

  enqueue('S',id,type,scan) ;
  }

@ Proto.
@<Prototypes@>+=
void handle_scan(char *text) ;

@ Entry.
@<Functions@>+=
void 
handle_entry(char *text)
  {
  int id ;
  char data[256+1] ;
  int t,d ;

  Inform("entry %s",text) ;
 
  t = 1 ;

  d = 0 ;
  data[d  ] = '\0' ;
  while((text[t]!='\0') && (text[t]!='|') && (d<(256-1)))
    {
    data[d++] = text[t++] ;
    data[d  ] = '\0' ; 
    }
  id = atoi(data) ;

  if(text[t]=='|') t++ ;

  d = 0 ;
  data[d  ] = '\0' ;
  while((text[t]!='\0') && (text[t]!='|') && (d<(256-1)))
    {
    data[d++] = text[t++] ;
    data[d  ] = '\0' ;
    }

  enqueue('E',id,' ',data) ;
  }

@ Proto.
@<Prototypes@>+=
void handle_entry(char *text) ;

@ Button.
@<Functions@>+=
void 
handle_button(char *text)
  {
  int id ;
  char data[256+1] ;
  int t,d ;

  Inform("button %s",text) ;
 
  t = 1 ;

  d = 0 ;
  data[d  ] = '\0' ;
  while((text[t]!='\0') && (text[t]!='|') && (d<(256-1)))
    {
    data[d++] = text[t++] ;
    data[d  ] = '\0' ; 
    }
  id = atoi(data) ;

  enqueue('B',id,' ',"") ;
  }

@ Proto.
@<Prototypes@>+=
void handle_button(char *text) ;

@ Function Key.
@<Functions@>+=
void 
handle_fkey(char *text)
  {
  int id ;
  char data[256+1] ;
  int t,d ;

  Inform("fkey %s",text) ;
 
  t = 1 ;

  d = 0 ;
  data[d  ] = '\0' ;
  while((text[t]!='\0') && (text[t]!='|') && (d<(256-1)))
    {
    data[d++] = text[t++] ;
    data[d  ] = '\0' ; 
    }
  id = atoi(data) ;

  enqueue('F',id,' ',"") ;
  }

@ Proto.
@<Prototypes@>+=
void handle_fkey(char *text) ;

@* Machine.
@<Globals@>+=
int state = -1 ;
int request = 0 ;
int entry_time = 0 ;
int entry = 0 ;
char *state_name[100] ;
char error_message[1024+1] ;
int  error_return ;
char shipmentBarcode[32+1] ;
char shipmentID[32+1] ;
char cartonizationSize[16+1] ;
char actualSize[16+1] ;
int hazmat = 0 ;
int xhazmat = 0 ;
int page = 0 ;
int start = 0 ;
char last_sku[32+1] ;
int last_hazmat ;
char highlight[32+1] ;
char cartons[12][16+1] ;
int  carton_n = 0 ;

@ Elapsed.
@<Functions@>+=
int elapsed(void)
  {
  return time(NULL) - entry_time ;
  }

@ Proto.
@<Prototypes@>+=
int elapsed(void) ;

@ Set state.
@<Functions@>+=
void set_state(int ask) 
  {
  request = ask ;
  }

@ Proto.
@<Prototypes@>+=
void set_state(int ask) ;

@ Redraw.
@<Functions@>+=
void redraw(void)
  {
  if(state>=0)
    request = state ;
  state = -1 ;
  }

@ Proto.
@<Prototypes@>+=
void redraw(void) ;

@ Set error.
@<Functions@>+=
void set_error(char *text)
  {
  strncpy(error_message,text,128) ;
  error_return = state ;
  set_state(S_ERROR) ;
  }

@ Proto.
@<Prototypes@>+=
void set_error(char *text) ;

@ Status.
@<Functions@>+=
void status(void)
  {
  static time_t last = 0 ;
  char datetime[32+1] ;
  time_t stamp ;
  struct tm *now ;

  stamp = time(NULL) ;
  if(stamp==last) return ;
  last = stamp ;

  now = localtime(&stamp) ;

  thin_text(1010,   10,1035,35,"Station:",DARK_GRAY,0) ;
  thin_text(1015,  200,1035,35,stationName,WHITE,0) ;

  if(operatorName[0]!='\0')
    {
    thin_text(1020,  450,1035,35,"User:",DARK_GRAY,0) ;
    thin_text(1025,  575,1035,35,operatorName,WHITE,0) ;
    }

  sprintf(datetime,"%2d:%02d:%02d",
          now->tm_hour, now->tm_min, now->tm_sec) ;
  thin_text(1090,1700,1035,35,datetime,WHITE,0) ;

  thin_rect(1100,0,1030,1920,50,BLACK,0) ; 
  }

@ Proto.
@<Prototypes@>+=
void status(void) ;

@ Crank.
@<Functions@>+=
void machine(void)
  {
  if(request!=state)
    {
    Inform("new state %d %s",request,state_name[request]) ;
    entry_time = time(NULL) ;
    entry = 1 ;
    state = request ;
    setup() ;
    }

  switch(state)
    {
    @<States@>@;
    }
  
  entry = 0 ;
  status() ;
  }

@ Proto.
@<Prototypes@>+=
void machine(void) ;

@ *Process.

@ Init.
@<Defines@>+=
#define S_INIT (0)

@ Name the state.
@<Initialize@>+=
state_name[S_INIT] = "init" ;

@ Init State.
@<States@>+=
case S_INIT:
  {
  if(entry)
    {
    thin_clear(BLACK) ;
    thin_text(1,100,100,50,"System starting...",WHITE,0) ;
    scan_disable() ;
    hist_post(stationName,"system","system started") ; 
    }

  if(elapsed()>0)
    set_state(S_LOGIN) ;
  }
break ;

@ Log In.
@<Defines@>+=
#define S_LOGIN (1)

@ Name the state.
@<Initialize@>+=
state_name[S_LOGIN] = "login" ;

@ Log In State.
@<States@>+=
case S_LOGIN:
  {
  char source, type ;
  int id ;
  char operator[Q_TEXT+1] ;

  if(entry)
    {
    thin_clear(DARK_GRAY) ;

    thin_text(1,100,100,50,"Scan User ID barcode to log in.",WHITE,0) ;

    thin_text(2,100,200,35,"User ID:",LIGHT_GRAY,0) ; 
    thin_entry(3,100,250,1000,75,50) ;
    thin_focus(3) ;

    scan_enable() ;
   
    operatorName[0] = '\0' ;
    }

  if(dequeue(&source,&id,&type,operator))
    {
    if((source=='S') || ((source=='E') && (id==3)))
      {
      int err ;

      Inform("operator [%s]",operator) ;
      operatorName[0] = '\0' ;
      err = sql_query("SELECT name FROM ylOperators "
                      "WHERE operator = '%s' ",operator) ;
      if(!err)
        if(sql_rowcount()>0)
          if(sql_get(0,0))
            {
            strncpy(operatorName,sql_get(0,0),64) ;
            operatorName[64] = '\0' ;
            }

      if(operatorName[0]!='\0')
        {
        char desc[128+1] ;

        sprintf(desc,"User %s %s logged in",
                operator,operatorName) ;
        hist_post(stationName,"operator",desc) ;

        scan_beep() ;
        set_state(S_DOCUMENT) ;
        }
      else
        {
        char desc[128+1] ;

        sprintf(desc,"User %s fails to log in, unknown",
                operator) ;
        hist_post(stationName,"operator",desc) ; 

        set_state(S_LOGIN_ERR);
        }
      }
    }

  }
break ;

@ Login Error.
@<Defines@>+=
#define S_LOGIN_ERR (10)

@ Name the state
@<Initialize@>+=
state_name[S_LOGIN_ERR] = "login error" ;

@ Login error state.
@<States@>+=
case S_LOGIN_ERR:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;

  if(entry)
    {
    thin_clear(AMBER) ;

    thin_text(1,100,100,50,"Unknown operator ID.",WHITE,0) ;

    thin_button(10,1350,850,400,75,50,"RETRY") ;
    scan_error() ;
    }

  if(elapsed()>5)
    set_state(S_LOGIN) ;

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      set_state(S_LOGIN) ;
    }
  }
break ;

@ Scan Document.
@<Defines@>+=
#define S_DOCUMENT (3)

@ Name the state.
@<Initialize@>+=
state_name[S_DOCUMENT] = "scan document" ;

@ Scan Document State.
@<States@>+=
case S_DOCUMENT:
  {
  char source, type ;
  int id ;
  char text[Q_TEXT+1] ;

  if(entry)
    {
    thin_clear(BLUE) ;

    thin_text(1,100,100,50,"Scan Packing Slip to begin processing.",WHITE,0) ;

    thin_text(2,100,200,35,"Packing Slip:",LIGHT_GRAY,0) ; 
    thin_entry(3,100,250,1000,75,50) ;
    thin_focus(3) ;

    thin_button(1000,1350,850,400,75,50,"LOG OUT") ;

    scan_enable() ;
    }

  if(dequeue(&source,&id,&type,text))
    {
    if((source=='B') && (id==1000))
      {
      char desc[128+1] ;

      sprintf(desc,"Operator %s logs out",operatorName) ;
      hist_post(stationName,"operator",desc) ;

      operatorName[0] = '\0' ;
      set_state(S_LOGIN) ;
      }

    if((source=='S') || ((source=='E') && (id==3)))
      {
      int err ;
      int order_status ;
      char desc[128+1] ;
      char doc[Q_TEXT+1] ;
      int t,d,digits ;

      d=0 ;
      doc[d  ] = '\0' ;
      digits = 0 ;
      for(t=0; t<strlen(text) ; t++)
        {
        if(!digits && (text[t]>='0') && (text[t]<='9'))
          digits = 1 ;

        if(digits)
          {
          if((text[t]>='0') && (text[t]<='9'))
            {
            doc[d++] = text[t] ;
            doc[d  ] = '\0' ;
            }
          else
            break ;
          }
        }
      Inform("text [%s] doc [%s]",text,doc) ;

      order_status = 0 ;
      err = sql_query("SELECT shipmentID, status, "
                      "cartonizationSize, actualSize, "
                      "hazmat, xhazmat "
                      "FROM ylOrders "
                      "WHERE shipmentBarcode='%s' ",doc) ;
      if(!err)
        {
        if(sql_rowcount()>0)
          {
          shipmentID[0] = '\0' ;
          if(sql_get(0,0))
            strncpy(shipmentID,sql_get(0,0),32) ; 
          shipmentID[32] = '\0' ;

          order_status = 0 ; 
          if(sql_get(0,1))
            order_status = atoi(sql_get(0,1)) ;

          cartonizationSize[0] = '\0' ;
          if(sql_get(0,2))
            strncpy(cartonizationSize,sql_get(0,2),16) ;
          cartonizationSize[16] = '\0' ;

          actualSize[0] = '\0' ;
          if(sql_get(0,3))
            strncpy(actualSize,sql_get(0,3),16) ;
          actualSize[16] = '\0' ;

          hazmat = 0 ;
          if(sql_get(0,4))
            hazmat = (sql_get(0,4)[0]=='y') ? 1 : 0 ;

          xhazmat = 0 ;
          if(sql_get(0,5))
            xhazmat = (sql_get(0,5)[0]=='y') ? 1 : 0 ;

          Inform("shipment found, ID %s status %d hazmat %d xhazmat %d",
                 shipmentID,order_status,hazmat,xhazmat) ;


          err = sql_query("UPDATE ylOrders "
                          "SET packOperator='%s',"
                          "packStation='%s', "
                          "packDateTime=NOW() "
                          "WHERE shipmentID='%s' ",
                          operatorName,
                          stationName,
                          shipmentID) ;
          if(err)
            Alert("SQL error %d update ylOrders ",err) ;
          }
        }
      else
        {
        char desc[128+1] ;

        Alert("SQL error %d select ylOrders",err) ;

        sprintf(desc,"Document %s not found",doc) ;
        hist_post(stationName,"packlist",desc) ;
        }


      if((order_status==10) || (order_status==20))
        { 
        strncpy(shipmentBarcode,doc,32) ;
        shipmentBarcode[32] = '\0' ;

        sprintf(desc,"Scanned at %s by %s",
                stationName,operatorName) ;
        hist_post(shipmentID,"packlist",desc) ;

        scan_beep() ; 

        if(order_status==10)
          set_state(S_CHANGE_BOX) ;
        else 
          set_state(S_CARTON) ;
        } 
      else if((order_status==30) || (order_status==40))
        {
        strncpy(shipmentBarcode,doc,32) ;
        shipmentBarcode[32] = '\0' ;

        sprintf(desc,"Re-scanned at %s by %s",
                stationName,operatorName) ;
        hist_post(shipmentID,"packlist",desc) ;

        scan_beep() ;
        set_state(S_ITEMS) ;
        }
      else if(order_status==10)
        {
#if 0
        sprintf(desc,"Not ready to be processed at %s by %s",
                stationName,operatorName) ;
        hist_post(shipmentID,"packlist",desc) ;

        set_error("Order has not yet been cartonized.") ;
#endif
        }
      else if(order_status==50)
        {
        sprintf(desc,"Re-scanned at %s by %s, already complete",
                stationName,operatorName) ;
        hist_post(shipmentID,"packlist",desc) ;

        set_error("This order has been completed.") ; 
        }
      else if(order_status<0)
        {
        set_state(S_ORDER_ERROR) ; 
        }
      else if(order_status==0)
        {
        set_state(S_ORDER_NOT_FOUND) ;
        }
      else
        {
        Alert("unknown status %d",order_status) ;
        set_error("Unknown order status") ;
        }
      }
    } 
  }
break ;

@ Supervisor.
@<Defines@>+=
#define S_SUPERVISOR (30)

@ Name the state.
@<Initialize@>+=
state_name[S_SUPERVISOR] = "supervisor required" ;

@ Supervisor State.
@<States@>+=
case S_SUPERVISOR:
  {
  char source, type ;
  int id ;
  char operator[Q_TEXT+1] ;

  if(entry)
    {
    char desc[128+1] ;

    thin_clear(DARK_GREEN) ;

    thin_text(1,100,100,50,"Scan supervisor barcode to continue.",WHITE,0) ;

    thin_text(2,100,200,35,"Supervisor ID:",LIGHT_GRAY,0) ; 
    thin_entry(3,100,250,1000,75,50) ;
    thin_focus(3) ;

    thin_text(4,100,400,35,
              "This order requires a supervisor's permission to continue.",
              WHITE,0) ;

    thin_button(10,1350,850,400,75,50,"CANCEL") ;

    hist_post(shipmentID,"approval","Requires supervisor approval to continue") ;
    scan_enable() ;
    }

  if(dequeue(&source,&id,&type,operator))
    {
    if((source=='S') || ((source=='E') && (id==3)))
      {
      int err ;
      int isAdmin = 0 ;
      char supervisorName[64+1] ;

      Inform("operator [%s]",operator) ;
      supervisorName[0] = '\0' ;
      isAdmin = 0 ;
      err = sql_query("SELECT name, isAdmin FROM ylOperators "
                      "WHERE operator = '%s' ",operator) ;
      if(!err)
        {
        if(sql_rowcount()>0)
          {
          if(sql_get(0,0))
            strncpy(supervisorName,sql_get(0,0),64) ;
          supervisorName[64] = '\0' ;
    
          if(sql_get(0,1))
            if(sql_get(0,1)[0]=='y') 
              isAdmin = 1 ;
          }
        }
      else
        Alert("SQL error %d select ylOperators",err) ;

      if(supervisorName[0]!='\0')
        {
        if(isAdmin)
          {
          char desc[128+1] ;
          int err ;
      
          sprintf(desc,"Approved by %s",supervisorName) ;
          hist_post(shipmentID,"approval",desc) ;

          err = sql_query("UPDATE ylOrders "
                          "SET approvedBy='%s', "
                          "approveStamp=NOW() "
                          "WHERE shipmentID='%s' ",
                          supervisorName,shipmentID) ;
          if(err)
            Alert("SQL error %d update ylOrders",err) ;

          set_state(S_ITEMS) ;
          } 
        else
          {
          char temp[64+1] ;

          sprintf(temp,"Not approved, user %s is not a supervisor.",supervisorName) ;
          hist_post(shipmentID,"approval",temp) ;

          set_error(temp) ;
          }
        }
      else
        {
        char temp[64+1] ;

        sprintf(temp,"Not approved, user ID %s not found.",operator) ;
        hist_post(shipmentID,"approval",temp) ;

        set_error(temp) ; 
        }
      }
    if((source=='B') && (id==10))
      {
      char temp[64+1] ;

      sprintf(temp,"Supervisor approval canceled") ;
      hist_post(shipmentID,"approval",temp) ;

      set_state(S_ITEMS) ;
      }
    }
  }
break ;

@ Order Error.
@<Defines@>+=
#define S_ORDER_ERROR (31)

@ Name the state.
@<Initialize@>+=
state_name[S_ORDER_ERROR] = "order error" ;

@ Order Error State.
@<States@>+=
case S_ORDER_ERROR:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;

  if(entry)
    {
    int err ;
    char reason[128+1]  ;

    thin_clear(RED) ;

    thin_text(1,100,100,50,
              "This order cannot be packed at this station.",WHITE,0) ;

    strcpy(reason,"Unknown problem.") ;
    err = sql_query("SELECT message FROM ylOrders "
                    "WHERE shipmentID='%s' ",shipmentID) ;
    if(!err)
      {
      if(sql_rowcount()>0)
        if(sql_get(0,0))
        strncpy(reason,sql_get(0,0),128) ;
      reason[128] = '\0' ;
      }
    else
      Alert("SQL error %d select ylOrders",err) ;

    thin_text(2,100,200,35,"Reason:",GRAY, 0) ;
    thin_text(3,100,250,35,reason,   WHITE,0) ;
    
    thin_button(10,1350,850,400,75,50,"CANCEL") ;

    scan_error() ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      {
      set_state(S_DOCUMENT) ;
      }
    }

  }
break ;

@ Order Not Found.
@<Defines@>+=
#define S_ORDER_NOT_FOUND (32)

@ Name the state.
@<Initialize@>+=
state_name[S_ORDER_NOT_FOUND] = "order not found" ;

@ Order Not Found State.
@<States@>+=
case S_ORDER_NOT_FOUND:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;

  if(entry)
    {
    thin_clear(RED) ;

    thin_text(1,100,100,50,
              "This order cannot be found",WHITE,0) ;

    thin_button(10,1350,850,400,75,50,"RETRY") ;

    scan_error() ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      {
      set_state(S_DOCUMENT) ;
      }
    }

  }
break ;

@ Carton
@<Defines@>+=
#define S_CARTON (4)

@ Name the state.
@<Initialize@>+=
state_name[S_CARTON] = "carton" ;

@ Carton Select State.
@<States@>+=
case S_CARTON:
  {
  if(entry)
    {
    char desc[128+1] ;

    thin_clear(BROWN) ;

    thin_text(1,100,100,50,"Start a new carton.",WHITE,0) ;
     
    thin_text(2,100,200,35,"Carton Size:",LIGHT_GRAY,0) ; 
    thin_text(3,100,250,75,cartonizationSize,WHITE,0) ;

    sprintf(desc,"Requested carton size %s",cartonizationSize) ;
    hist_post(shipmentID,"carton",desc) ;
    }

  if(elapsed()>=2)
    {
    page = 0 ;
    last_sku[0] = '\0' ;
    last_hazmat = 0 ;
    highlight[0] = '\0' ;
    set_state(S_ITEMS) ;
    }
  }
break ;

@ Items.
@<Defines@>+=
#define S_ITEMS (5)

@ Name the state.
@<Initialize@>+=
state_name[S_ITEMS] = "items" ;

@ Item scan state.
@<States@>+=
case S_ITEMS:
  {
  char source, type ;
  int id ;
  char value[Q_TEXT+1] ;
  char desc[128+1] ;

  if(entry)
    {
    int products ;
    int expected ;
    int scanned ;
    int packed   ;
    int remaining ;
    char temp[32+1] ;
    int i ;
    int page_size = 20 ;
    start     =  page * page_size ;

    thin_clear(LIGHT_GRAY) ;

    thin_text( 1,  50, 25, 50,"Scan Items.",BLACK,0) ;
   

    thin_text( 4, 450, 20, 25,"Shipment ID:",BLACK,0) ;
    thin_text( 5, 700, 20, 25,shipmentID,DARK_BLUE,0) ;
  
    thin_text( 6, 450, 50,25,"Carton Size:",BLACK,0) ;
    thin_text( 7, 700, 50,25,actualSize,DARK_BLUE,0) ;
    
    if(hazmat)
      thin_text(14,1030, 20, 25, "Dangerous Goods",AMBER,0) ;
    if(xhazmat)
      thin_text(15,1030, 50, 25, "Extremely Dangerous",RED,0) ;
 

    if(item_fill(shipmentID)==0)
      {
      int err ;

      products = item_n ;
      expected = 0 ;
      packed   = 0 ; 
      scanned  = 0 ;

      err = sql_query("UPDATE ylOrders SET status=30 "
                      "WHERE shipmentID='%s' "
                      "AND status=20 ",shipmentID) ;
      if(err)
        Alert("SQL error %d update ylOrders",err) ;

      for(i=0 ; i<item_n ; i++)
        {
        expected += items[i].expect ;
        scanned  += items[i].packed ;

        if(items[i].packed<items[i].expect)
          packed += items[i].packed ;
        else
          packed += items[i].expect ;

        if(0==strcmp(items[i].sku,highlight))
          {
          page = i / page_size ;
          start = page * page_size ;
          }
        }
      remaining = expected - packed ;
      }

    sprintf(temp,"%d",products) ;
    thin_text( 8,1400, 20, 25,"Products:",BLACK,0) ;
    thin_text( 9,1675, 20, 25,temp,DARK_BLUE,0) ;

    sprintf(temp,"%d of %d",scanned,expected) ;
    thin_text(10,1400, 50, 25,"Items Scanned:",BLACK,0) ;
    thin_text(11,1675, 50, 25,temp,DARK_BLUE,0) ;

    sprintf(temp,"%d",remaining) ;
    thin_text(12,1400, 80, 25,"Items Remaining:",BLACK,0) ;
    thin_text(13,1675, 80, 25,temp,DARK_BLUE,0) ;


    thin_text(21,   60,120, 20,"Product",BLACK,0) ;
    thin_text(22,  250,120, 20,"Description",BLACK,0) ;
    thin_text(23,  900,120, 20,"Pkg",BLACK,0) ;
    thin_text(24, 1000,120, 20,"Expect",BLACK,0) ;
    thin_text(25, 1100,120, 20,"Scanned",BLACK,0) ;
    thin_text(26, 1230,120, 20,"Manual",BLACK,0) ;

    for(i=0 ; i<page_size ; i++)
      {
      int y ;
      int r,g,b ;  

      if((start+i)>=item_n) break ;
 
      y = 150 + i*40 ;

      if(items[i+start].packed==0)
        {
        r = 0xA0 ;
        g = 0xA0 ;
        b = 0xA0 ;
        }
      else if((items[i+start].expect>0) && 
              (items[i+start].packed>=items[i+start].expect))
        {
        r = 0x00 ;
        g = 0x80 ;
        b = 0x00 ;
        }
      else if(items[i+start].expect==0)
        {
        r = 0xC0 ;
        g = 0x00 ;
        b = 0x00 ;
        }
      else 
        {
        r = 0xa0 ;
        g = 0x60 ;
        b = 0x00 ;
        }
        
      thin_text(100*(i+1)+1,  60, y, 32, items[i+start].sku,r,g,b,0) ;
      thin_text(100*(i+1)+2, 250, y, 32, items[i+start].desc,r,g,b,0) ;
      thin_text(100*(i+1)+3,920, y, 32, items[i+start].class,r,g,b,0) ;
      sprintf(temp,"%2d",items[i+start].expect) ;
      thin_text(100*(i+1)+4,1020, y, 32, temp,r,g,b,0) ;
      if(items[i+start].packed>items[i+start].expect)
        {
        r = 0x80 ;
        g = 0x00 ;
        b = 0x00 ;
        }
      sprintf(temp,"%2d",items[i+start].packed) ;
      thin_text(100*(i+1)+5,1130, y, 32, temp,r,g,b,0) ;

      thin_button(100*(i+1)+6,1250, y,60,32,25,"+") ;

      if(0==strcmp(items[i+start].sku,highlight))
        thin_rect(52,50,y,1175,40,WHITE,0) ;
      }
    thin_rect(20,  50,150, 1275,800,LIGHTER_GRAY,0) ;

    sprintf(temp,"Showing lines %d to %d of %d",
            start+1,
            ((start+page_size)<item_n) ? (start+page_size) : item_n,
            item_n) ;
    thin_text(30,  60,960,20,temp,BLACK,0) ;

    if(page>0)
      thin_button(31,500,960,175,45,40,"PREV") ;
    if((start+page_size)<item_n)
      thin_button(32,700,960,175,45,40,"NEXT") ;

    thin_text( 40,1375,150,35,"Item:",BLACK,0) ; 
    thin_entry(41,1375,200,500,75,50) ;
    thin_focus(41) ;

    if(last_sku[0]!='\0')
      {
      sprintf(temp,"OK: %s",last_sku) ;
      thin_text( 50,1390,310,50,temp,BLACK,0) ;
      if(last_hazmat)
        thin_rect( 51,1375,300,500,75,LIGHT_BLUE ,0) ; 
      else
        thin_rect( 51,1375,300,500,75,GREEN,0) ;
      }

    thin_button( 60,1450,500,400,75,50,"Tote Empty") ;
    thin_button( 61,1450,700,400,75,50,"Change Box") ;
    thin_button( 62,1450,800,400,75,50,"Suspend") ;
    thin_button( 63,1450,900,400,75,50,"Start Over") ;

    scan_enable() ;
    }


  if(elapsed()>5)
    {
    thin_text( 50,990,310,50,"",BLACK,0) ;
    thin_rect( 51,975,300,0,0,LIGHT_GRAY,0) ;
    thin_rect( 52,0,0,0,0,WHITE,0) ;
    last_sku[0]='\0' ;
    last_hazmat = 0 ; 
    highlight[0]='\0' ;
    }

  if(dequeue(&source,&id,&type,value))
    {
    int err ;

    if(   ((source=='E') && (id=41))
       || (source=='S') )
      {
      int result ;
      char add_sku[32+1] ;
     
      result = item_add(value,add_sku,0) ;
      Inform("item: %s result %d %s",
             value,result,add_sku) ;

      switch(result)
        {
        case 2:
          last_hazmat = 1 ;
          strcpy(last_sku,add_sku) ;
          strcpy(highlight,add_sku) ;
          sprintf(desc,"Scanned %s item %s added",
                  value,add_sku) ;
          hist_post(shipmentID,"item",desc) ;

          redraw() ;
          break ;
        case 1:
          last_hazmat = 0 ;
          strcpy(last_sku,add_sku) ;
          strcpy(highlight,add_sku) ;
          sprintf(desc,"Scanned %s item %s added",
                  value,add_sku) ;
          hist_post(shipmentID,"item",desc) ;

          redraw() ;
          break ;
        case -1:
          sprintf(desc,"Scanned %s, not an item",
                  value) ;
          hist_post(shipmentID,"item",desc) ;

          strcpy(error_message,value) ;
          set_state(S_ITEM_NOT) ;
          break ;
        case -2:
          sprintf(desc,"Scanned %s item %s, not expected",
                  value,add_sku) ;
          hist_post(shipmentID,"item",desc) ;

          err = sql_query("UPDATE ylOrders "
                          "SET misPicks=misPicks+1 "
                          "WHERE shipmentID='%s' ",
                          shipmentID) ;
          if(err)
            Alert("SQL error %d update ylOrders",err) ;

          strcpy(error_message,add_sku) ;
          strcpy(highlight,add_sku) ;
          set_state(S_ITEM_UNEXPECT) ;
          break ;
        case -3:
          sprintf(desc,"Scanned %s item %s, overpick",
                  value,add_sku) ;
          hist_post(shipmentID,"item",desc) ;

          err = sql_query("UPDATE ylOrders "
                          "SET overPicks=overPicks+1 "
                          "WHERE shipmentID='%s' ",
                          shipmentID) ;
          if(err)
            Alert("SQL error %d update ylOrders",err) ;

          strcpy(error_message,add_sku) ;
          strcpy(highlight,add_sku) ;
          set_state(S_ITEM_EXTRA) ;
          break ;
        default:
          break;
        }



      }

    if((source=='B') && (id==60))
      {
      // tote empty 
      set_state(S_EMPTY_TOTE) ;
      }

    if((source=='B') && (id==61))
      {
      set_state(S_CHANGE_BOX) ;
      }

    if((source=='B') && (id==62))
      {
      char desc[128+1] ;

      sprintf(desc,"Suspended at %s by %s",
              stationName,operatorName) ;
      hist_post(shipmentID,"packlist",desc) ;

      set_state(S_DOCUMENT) ;
      }

    if((source=='B') && (id==63))
      {
      int err ;
      char desc[128+1] ;

      sprintf(desc,"Restarted at %s by %s",
              stationName,operatorName) ;
      hist_post(shipmentID,"packlist",desc) ;

      err = sql_query("UPDATE ylOrders "
                      "SET misPicks=0, underPicks=0, overPicks=0 "
                      "WHERE shipmentID='%s' ",
                      shipmentID) ;
      if(err)
        Alert("SQL error %d update ylOrders",err) ;
      
      err = sql_query("DELETE FROM ylPackedItems "
                      "WHERE shipmentID='%s' ",shipmentID) ;
      if(err)
        Alert("SQL error %d delete ylPackedItems",err) ;

      redraw() ;
      }

    if((source=='B') && (id==31))
      {
      if(page>0) page-- ;
      highlight[0]='\0' ;
      redraw() ;
      }
   
    if((source=='B') && (id==32))
      {
      page++ ;
      highlight[0]='\0' ; 
      redraw() ;
      }

    if((source=='B') && (id>100))
      {
      int result ;
      char add_sku[32+1] ;
      char desc[128+1] ;
      int line = id/100 ;
      int i    = start + (line-1) ;

      Inform("button %d line %d i %d sku %s",
              id,line,i,items[i].sku) ;
     
      result = item_add(items[i].sku,add_sku,1) ;
      Inform("item: %s result %d %s",
             items[i].sku,result,add_sku) ;

      switch(result)
        {
        case 2:
          last_hazmat = 1 ;
          sprintf(desc,"Manual add, item %s added",
                  add_sku) ;
          hist_post(shipmentID,"item",desc) ;

          strcpy(last_sku,add_sku) ;
          strcpy(highlight,add_sku) ;
          redraw() ;
          break ;
        case 1:
          last_hazmat = 0 ;
          sprintf(desc,"Manual add, item %s added",
                  add_sku) ;
          hist_post(shipmentID,"item",desc) ;

          strcpy(last_sku,add_sku) ;
          strcpy(highlight,add_sku) ;
          redraw() ;
          break ;
        case -1:
          // should never happen
          sprintf(desc,"Manual add, item %s not in order",
                  items[i].sku) ;
          hist_post(shipmentID,"item",desc) ;

          strcpy(error_message,value) ;
          set_state(S_ITEM_NOT) ;
          break ;
        case -2:
          // should never happen
          sprintf(desc,"Manual add, item %s not expected",
                  add_sku) ;
          hist_post(shipmentID,"item",desc) ;

          strcpy(error_message,add_sku) ;
          strcpy(highlight,add_sku) ;
          set_state(S_ITEM_UNEXPECT) ;
          break ;
        case -3:
          sprintf(desc,"Manual add, item %s overpick",
                  add_sku) ;
          hist_post(shipmentID,"item",desc) ;

          strcpy(error_message,add_sku) ;
          strcpy(highlight,add_sku) ;
          set_state(S_ITEM_EXTRA) ;
          break ;
        default:
          break;
        }
      }
    }

  }
break ;

@ Not an item.
@<Defines@>+=
#define S_ITEM_NOT (51)

@ Name the state.
@<Initialize@>+=
state_name[S_ITEM_NOT] = "not an item" ;

@ Not an Item State.
@<States@>+=
case S_ITEM_NOT:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;

  if(entry)
    {
    thin_clear(RED) ;

    thin_text(1,100,100,50,"Not recognized as an item.",WHITE,0) ;

    thin_text(2,100,200,35,"Scanned:",LIGHT_GRAY,0) ; 
    thin_text(3,100,250,50,error_message,WHITE,0) ;

    thin_button(10,1350,850,400,75,50,"RETRY") ;

    scan_error() ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      {
      last_sku[0] = '\0' ;
      last_hazmat = 0 ;
      highlight[0] = '\0' ;
      set_state(S_ITEMS) ;
      }
    }

  }
  break ;

@ Not in order.
@<Defines@>+=
#define S_ITEM_UNEXPECT (52)

@ Name the state.
@<Initialize@>+=
state_name[S_ITEM_UNEXPECT] = "not in order" ;

@ Not in Order State.
@<States@>+=
case S_ITEM_UNEXPECT:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;
  int err ;
  char desc[32+1] ;

  if(entry)
    {
    thin_clear(RED) ;

    thin_text(1,100,100,50,"Item not expected in this order.",WHITE,0) ;

    thin_text(2,100,200,35,"Item:",LIGHT_GRAY,0) ; 
    thin_text(3,100,250,50,error_message,WHITE,0) ;
  
    desc[0] = '\0' ; 
    err = sql_query("SELECT description "
                    "FROM ylSkus "  
                    "WHERE sku='%s' "
                    "AND unitOfMeasure='EA' ",error_message) ;
    if(!err)
      if(sql_rowcount()>0)
        if(sql_get(0,0))
          strncpy(desc,sql_get(0,0),32) ;
    desc[32] = '\0' ;
    thin_text(4,100,325,35,"Description:",LIGHT_GRAY,0) ;
    thin_text(5,100,375,50,desc,WHITE,0) ;

    thin_text(6,100,500,50,"Set the item in the bin for extra items",WHITE,0) ;
    thin_text(7,100,560,50,"and press CONTINUE. ",WHITE,0) ;

    thin_button(10,1350,850,400,75,50,"CONTINUE") ;

    scan_error() ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      {
      int err ;

      err = sql_query("INSERT INTO ylPackedItems "
                      "(shipmentID,sku,unitOfMeasure,actualQty) "
                      "VALUES "
                      "('%s','%s','EA',1) "
                      "ON DUPLICATE KEY "
                      "UPDATE actualQty = actualQty+1 ",
                      shipmentID,error_message) ;
      if(err)
        Alert("SQL error %d insert ylPackedItems",err) ;

      last_sku[0] = '\0' ;
      last_hazmat = 0 ;
      set_state(S_ITEMS) ;
      }
    }
  }
  break ;

@ Extra Items.
@<Defines@>+=
#define S_ITEM_EXTRA (53)

@ Name the state.
@<Initialize@>+=
state_name[S_ITEM_EXTRA] = "extra item" ;

@ Extra Item.
@<States@>+=
case S_ITEM_EXTRA:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;
  int err ;
  char desc[32+1] ;

  if(entry)
    {
    thin_clear(RED) ;

    thin_text(1,100,100,50,"Item exceeds quantity expected in this order.",WHITE,0) ;

    thin_text(2,100,200,35,"Item:",LIGHT_GRAY,0) ; 
    thin_text(3,100,250,50,error_message,WHITE,0) ;
  
    desc[0] = '\0' ; 
    err = sql_query("SELECT description "
                    "FROM ylSkus "  
                    "WHERE sku='%s' "
                    "AND unitOfMeasure='EA' ",error_message) ;
    if(!err)
      if(sql_rowcount()>0)
        if(sql_get(0,0))
          strncpy(desc,sql_get(0,0),32) ;
    desc[32] = '\0' ;
    thin_text(4,100,325,35,"Description:",LIGHT_GRAY,0) ;
    thin_text(5,100,375,50,desc,WHITE,0) ;

    thin_text(6,100,500,50,"Set the item in the bin for extra items",WHITE,0) ;
    thin_text(7,100,560,50,"and press CONTINUE. ",WHITE,0) ;

    thin_button(10,1350,850,400,75,50,"CONTINUE") ;

    scan_error() ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      {
      int i ;

      for(i=0 ; i<item_n ; i++)
        if(0==strcmp(items[i].sku,error_message))
          break ;

      if(i<item_n)
        {
        int err ;

        err = sql_query("INSERT INTO ylPackedItems "
                        "(shipmentID,sku,unitOfMeasure,"
                        "intendedQty,actualQty,makeUpQty) "
                        "VALUES ('%s','%s','%s',%d,%d,0) "
                        "ON DUPLICATE KEY "
                        "UPDATE actualQty=actualQty+1 ",
                        shipmentID,items[i].sku,"EA",
                        items[i].expect,items[i].packed+1) ;
        if(err)
          Alert("SQL error %d update ylPackedItems",err) ;
        }
      last_sku[0] = '\0' ;
      last_hazmat = 0 ;
      set_state(S_ITEMS) ;
      }
    }
  }
  break ;

@ Empty Tote.
@<Defines@>+=
#define S_EMPTY_TOTE (54)

@ Name the state.
@<Initialize@>+=
state_name[S_EMPTY_TOTE] = "empty tote" ;

@ Empty Tote State.
@<States@>+=
case S_EMPTY_TOTE:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;

  if(entry)
    {
    thin_clear(DARK_GRAY) ;

    thin_text(1,100,100,50,"Confirm that all items have been scanned.",WHITE,0) ;

    thin_button(10, 350,900,400,75,50,"Cancel") ;
    thin_button(20,1350,900,400,75,50,"Confirm") ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      {
      hist_post(shipmentID,"packlist","Tote empty cancelled") ;      
      set_state(S_ITEMS) ;
      }
    if((source=='B') && (id==20))
      {
      int complete = 1 ;
      int i ;
      for(i=0 ; i<item_n ; i++)
        if(items[i].packed<items[i].expect)
          complete = 0 ;

      if(complete)
        {
        int needed ;
        int err ;
        char approvedBy[32+1] ;

        needed = 0 ;
        approvedBy[0] = '\0' ;
        err = sql_query("SELECT approvalNeeded, approvedBy "
                        "FROM ylOrders "
                        "WHERE shipmentID='%s' ",shipmentID) ;
        if(!err)
          {
          if(sql_rowcount()>0)
            {
            if(sql_get(0,0))
              needed = (sql_get(0,0)[0]=='y')?1:0 ;
            if(sql_get(0,1))
              strncpy(approvedBy,sql_get(0,1),32) ;
            approvedBy[32] = '\0' ;
            }
          }
        else
          {
          Alert("SQL error %d select ylOrders",err) ; 
          }
        Inform("needed %d by %s",needed,approvedBy) ;
        
        if(needed && (approvedBy[0]=='\0'))
          set_state(S_SUPERVISOR) ;
        else
          set_state(S_DONE) ;
        }
      else
        set_state(S_HOLD) ;
      }
    }
  }
break ;

@ Done.
@<Defines@>+=
#define S_DONE (55)

@ Name the state.
@<Initialize@>+=
state_name[S_DONE] = "done" ;

@ Done State.
@<States@>+=
case S_DONE:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;
  int err ;
  char desc[128+1] ;

  if(entry)
    {
    thin_clear(MED_GREEN) ;

    thin_text(1,100,100,50,"Packing complete.",WHITE,0) ;
    thin_text(2,100,200,35,"Place completed carton on conveyor",WHITE,0) ;

    thin_button(10,1350,900,400,75,50,"Continue") ;

    hist_post(shipmentID,"packlist","Complete") ;

    err = sql_query("UPDATE ylOrders "
                    "SET status=50, "
                    "packStatus='Complete', "
                    "packStamp=NOW(), "
                    "message='Complete' "
                    "WHERE shipmentID='%s' ",
                    shipmentID) ;
    if(err)
      Alert("SQL error %d update ylOrders ",err) ;

    scan_disable() ;
    }

  if(elapsed()>5)
    set_state(S_DOCUMENT) ;
 
  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      {
      set_state(S_DOCUMENT) ;
      }
    }
  }
break ;

@ Hold.
@<Defines@>+=
#define S_HOLD (56)

@ Name the state.
@<Initialize@>+=
state_name[S_HOLD] = "hold" ;

@ Hold State.
@<States@>+=
case S_HOLD:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;
  char desc[128+1] ;
  int err ;

  if(entry)
    {
    int i ;
    int j ;
    int k ;
    thin_clear(ORANGE) ;

    thin_text(1,100,100,50,"Packing incomplete.",WHITE,0) ;
    thin_text(2,100,200,35,"Makeup items are being picked to complete order.",WHITE,0) ;
    thin_text(3,100,250,35,"Place carton aside until the makeup items are delivered.",WHITE,0) ;

    j = 0 ;
    for(i=0 ; i<item_n ; i++)
      {
      if(items[i].packed<items[i].expect)
        {
        char temp[64+1] ;
        char desc[128+1] ;

        sprintf(temp,"%d",items[i].expect-items[i].packed) ;
        thin_text(100+j,200+500*(j/14),350+(j%14)*35,25,temp,WHITE,0) ;
        thin_text(200+j,250+500*(j/14),350+(j%14)*35,25,items[i].desc,WHITE,0) ;

        sprintf(desc,"request makeup %s qty %d",
                items[i].desc,items[i].expect-items[i].packed) ;
        hist_post(shipmentID,"makeup",desc) ;

        // RME 10-26-18
        strcpy( desc, items[i].desc );
        for ( k = 0; k < strlen( desc ); k++ )
           if ( desc[k] == '\'' )
              desc[k] = ' ';

        err = sql_query("INSERT INTO ylMakeupItems "
                        "(shipmentID,sku,qty,description,pickLocation) "
                        "VALUES "
                        "('%s','%s',%d,'%s','%s') ",
                        shipmentID,items[i].sku,
                        items[i].expect-items[i].packed,
                        desc,items[i].location) ;
        if(err)
          Alert("SQL error %d insert ylMakeupItems",err) ;

        j++ ;
        }
      }

    err = sql_query("INSERT INTO ylMakeup " 
                    "(shipmentID,printerID,packStation) "
                    "VALUES "
                    "('%s','%s','%s') ",
                    shipmentID,printerID,stationName) ;
    if(err)
      Alert("SQL error %d insert ylMakeup",err) ;
    
    sprintf(desc,"Set aside for make-ups at %s by %s",
            stationName,operatorName) ;
    hist_post(shipmentID,"packlist",desc) ;

    thin_button(10,1350,900,400,75,50,"Continue") ;

    scan_disable() ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id==10))
      {
      set_state(S_DOCUMENT) ;
      }
    }
  }
break ;


@ Change Box.
@<Defines@>+=
#define S_CHANGE_BOX (6)

@ Name the state.
@<Initialize@>+=
state_name[S_CHANGE_BOX] = "change box" ;

@ Change Box.
@<States@>+=
case S_CHANGE_BOX:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;

  if(entry)
    {
    int err ;

    thin_clear(BROWN) ;

    thin_text(1,100,100,50,"Choose a new carton size.",WHITE,0) ;

    if(hazmat)
      {
      err = sql_query("SELECT carton FROM ylCartons "
                      "WHERE enabled='yes' "
                      "AND hazmat='yes' "
                      "ORDER BY carton "
                      "LIMIT 12 ") ;
      }
    else
      {
      err = sql_query("SELECT carton FROM ylCartons "
                      "WHERE enabled='yes' "
                      "ORDER BY carton "
                      "LIMIT 12 ") ;
      }
     
    if(!err)
      {
      int i, n ;
      n = sql_rowcount() ;
      for(i=0 ; i<n ; i++)
        {
        cartons[i][0]='\0' ;
        if(sql_get(i,0))
          strncpy(cartons[i],sql_get(i,0),16) ;
        cartons[i][16]='\0' ;
        carton_n++ ;

        thin_button(10*(i+1),
                    300+700*(i/6),200+(i%6)*100,
                    600,75,
                    60,cartons[i]) ;
        } 
      }
    else
      Alert("SQL error %d select ylCartons",err) ;  

    scan_disable() ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id>=10))
      {
      int err ;
      char desc[128+1] ;
      int i = id/10 - 1 ;
      
      strncpy(actualSize,cartons[i],16) ;
      actualSize[16] = '\0' ;

      err = sql_query("UPDATE ylOrders "
                      "SET actualSize='%s' "
                      "WHERE shipmentID='%s' ",
                      actualSize,shipmentID) ;
      if(err)
        Alert("SQL error %d update ylOrders",err) ;

      sprintf(desc,"Carton %s selected at %s by %s",
              actualSize,stationName,operatorName) ;
      hist_post(shipmentID,"carton",desc) ;

      set_state(S_ITEMS) ;
      }
    }

  }
break ;

@ Error Page.
@<Defines@>+=
#define S_ERROR (99)

@ Name the state.
@<Initialize@>+=
state_name[S_ERROR] = "error" ;

@ Scan Document State.
@<States@>+=
case S_ERROR:
  {
  char source, type ;
  int id ;
  char dummy[Q_TEXT+1] ;

  if(entry)
    {
    thin_clear(RED) ;

    thin_text(1,100,100,50,"Error.",WHITE,0) ;
    thin_text(2,100,200,35,error_message,WHITE,0) ;

    thin_button(10,1350,850,400,75,50,"RETURN") ;
    scan_error() ;
    }

  if(dequeue(&source,&id,&type,dummy))
    {
    if((source=='B') && (id>=10))
      {
      set_state(error_return) ;
      }
    }

  }
break ;

@* Items.
@<Structures@>+=
struct item_struct
  {
  char sku[25+1] ;
  char uom[16+1] ;
  char upc[32+1] ;
  char desc[32+1] ;
  char class[16+1] ;
  char location[16+1] ;
  float value ;
  int hazmat ;
  int expect ;
  int packed ;
  } ;

@ A statically allocated maximal array of items.
@<Globals@>+=
struct item_struct items[ITEM_N] ;

@ The size.
@<Defines@>+=
#define ITEM_N (1000)

@ The current count.
@<Globals@>+=
int item_n = 0 ;

@ Fill the array with current values.
@<Functions@>+=
int
item_fill(char *shipmentID)
  {
  int err ;

  item_n = 0 ;

  err = sql_query("SELECT i.sku, i.unitOfMeasure, i.qty, i.pickLocation, "
                  "s.upc, s.uomValue, s.description, s.hazmat "
                  "FROM ylOrderItems AS i "
                  "LEFT OUTER JOIN ylSkus AS s "
                  "ON s.sku=i.sku AND s.unitOfMeasure=i.unitOfMeasure "
                  "WHERE i.shipmentID = '%s' ",shipmentID) ;
  if(!err)
    {
    int n = sql_rowcount() ;
    if(n>0)
      {
      int i ;
      for(i=0 ; i<n ; i++)
        {
        items[item_n].sku[0]='\0' ;
        if(sql_get(i,0))
          strncpy(items[item_n].sku,sql_get(i,0),32) ;
        items[item_n].sku[32] = '\0' ;

        items[item_n].uom[0] = '\0' ;
        if(sql_get(i,1))
          strncpy(items[item_n].uom,sql_get(i,1),16) ;
        items[item_n].uom[16] = '\0' ;

        items[item_n].expect = 0 ;
        if(sql_get(i,2))
          items[item_n].expect = atoi(sql_get(i,2)) ;

        items[item_n].location[0]='\0' ;
        if(sql_get(i,3))
          strncpy(items[item_n].location,sql_get(i,3),16) ;
        items[item_n].location[16]='\0' ;

        items[item_n].upc[0]='\0' ;
        if(sql_get(i,4))
          strncpy(items[item_n].upc,sql_get(i,4),32) ;
        items[item_n].upc[32]='\0' ;

        items[item_n].value = 0.0f ;
        if(sql_get(i,5))
          items[item_n].value = atof(sql_get(i,5)) ;

        items[item_n].desc[0] = '\0' ;
        if(sql_get(i,6))
          strncpy(items[item_n].desc,sql_get(i,6),32) ;
        items[item_n].desc[32] = '\0' ;

        items[item_n].hazmat = 0 ;
        if(sql_get(i,7))
          if(sql_get(i,7)[0]=='y')
            items[item_n].hazmat = 1 ;
        items[item_n].packed = 0 ;
     
        item_n++ ;
        }
      }
    else
      {
      Alert("no items found") ;
      return -2 ;
      }

    err = sql_query("SELECT sku, unitOfMeasure, "
                    "actualQty, makeUpQty "
                    "FROM ylPackedItems "
                    "WHERE shipmentID='%s' ",shipmentID) ;
    if(!err)
      {
      int n = sql_rowcount() ;
      if(n>0)
        {
        int i ;
Inform("packed items %d",n) ;
        for(i=0 ; i<n ; i++)
          {
          char sku[32+1] ;
          char uom[16+1] ;
          int actual ;
          int makeup ;
          int j ;

          sku[0] = '\0' ;
          if(sql_get(i,0))
            strncpy(sku,sql_get(i,0),32) ;
          sku[32] = '\0' ;

          uom[0] = '\0' ;
          if(sql_get(i,1))
            strncpy(uom,sql_get(i,1),16) ;
          uom[16] = '\0' ;

          actual = 0 ;
          if(sql_get(i,2))
            actual = atoi(sql_get(i,2)) ;

          makeup = 0 ;
          if(sql_get(i,3))
            makeup = atoi(sql_get(i,3)) ;
 
          for(j=0 ; j<item_n ; j++)
            {
            if(0==strcmp(items[j].sku,sku))
              if(0==strcmp(items[j].uom,uom))
                break ;
            }
          if(j==item_n)
            {
            strcpy(items[item_n].sku,sku) ;
            strcpy(items[item_n].uom,uom) ;
            items[item_n].packed = actual ;
            items[item_n].upc[0] = '\0' ;
            items[item_n].desc[0] = '\0' ;
            items[item_n].class[0] = '\0' ;
            items[item_n].location[0] = '\0' ;
            items[item_n].value = 0.0f ;
            items[item_n].expect = 0 ;
            item_n++ ;
            }
          else
            {
            items[j].packed = actual ;
            }

          }
        }
      }
    else
      Alert("SQL error select ylPackedItems",err) ;
 
    if(1)
      {
      int i ;
      for(i=0 ; i<item_n ; i++)
        {
        if(items[i].desc[0]=='\0')
          {
          err = sql_query("SELECT upc, description "
                          "uomValue "
                          "FROM ylSkus "
                          "WHERE sku='%s' "
                          "AND unitOfMeasure='%s' ",
                          items[i].sku,items[i].uom) ;
          if(!err)
            {
            if(sql_rowcount()>0)
              {
              if(sql_get(0,0))
                strncpy(items[i].upc,sql_get(0,0),32) ;
              items[i].upc[32]='\0' ;

              if(sql_get(0,1))
                strncpy(items[i].desc,sql_get(0,1),32) ;
              items[i].desc[32]='\0' ;
    
              if(sql_get(0,2))
                items[i].value = atof(sql_get(0,2)) ;
              }
            }
          else
            {
            Alert("SQL error %d select ylSkus",err) ; 
            }
          }
        }
      } 
    }
  else
    {
    Alert("SQL error %d select ylOrderItems",err) ;
    return -1 ;
    }

  return 0 ;
  }

@ Proto.
@<Prototypes@>+=
int item_fill(char *shipmentID) ;

@ Item Add.
@<Functions@>+=
int
item_add(char *raw_scan, char *add_sku, int manual)
  {
  int result = 0 ;
  int err ;
  char sku[32+1] ;
  char scan[Q_TEXT+1] ;

  if(strncmp(raw_scan,"]C1",3)==0)
    strcpy(scan,raw_scan+3) ;
  else
    strcpy(scan,raw_scan) ;

  add_sku[0] = '\0' ;

  sku[0]='\0' ;

  if(manual)
    {
    strncpy(sku,scan,32) ;
    sku[32] = '\0' ;
    }
  else
    {
    err = sql_query("SELECT sku "
                    "FROM ylSkus "
                    "WHERE upc='%s' "
                    "AND unitOfMeasure='EA' ",scan) ;
    if(!err)
      {
      if(sql_rowcount()>0)
        {
        if(sql_get(0,0))
          strncpy(sku,sql_get(0,0),32) ;
        sku[32]='\0' ;
        } 
      }
    else
      Alert("SQL error %d select ylSkus",err) ; 

    if(sku[0]=='\0')
      {
      err = sql_query("SELECT sku "
                      "FROM ylSkus "
                      "WHERE sku='%s' "
                      "AND unitOfMeasure='EA' ",scan) ;
      if(!err)
        {
        if(sql_rowcount()>0)
          {
          if(sql_get(0,0))
            strncpy(sku,sql_get(0,0),32) ;
          sku[32]='\0' ;
          } 
        }
      else
        Alert("SQL error %d select ylSkus",err) ; 
      }
    }

  if(sku[0]!='\0')
    {
    int i ;

    Inform("sku %s",sku) ;
    strcpy(add_sku,sku) ;

    for(i=0 ; i<item_n ; i++)
      {
      if(0==strcmp(items[i].sku,sku))
        if(items[i].expect!=0)
          break ;
      }

    if(i<item_n)
      {
      Inform("found %d",i) ;

      if(items[i].packed < items[i].expect)
        {
        Inform("pack item %d sku %s",i,sku) ;

        err = sql_query("INSERT INTO ylPackedItems "
                        "(shipmentID,sku,unitOfMeasure,"
                        "intendedQty,actualQty,makeUpQty) "
                        "VALUES ('%s','%s','%s',%d,%d,0) "
                        "ON DUPLICATE KEY "
                        "UPDATE actualQty=actualQty+1 ",
                        shipmentID,sku,"EA",
                        items[i].expect,items[i].packed+1) ;
        if(err)
          Alert("SQL error %d update ylPackedItems",err) ;

        result = 1 ;
        if(items[i].hazmat)
          result = 2 ;
        }
      else
        {
        Alert("sku %s have %d expect %d",
              sku,items[i].packed+1,items[i].expect) ;
        result = -3 ;
        }
      }
    else
      {
      Alert("sku %s is not part of shipment",sku) ;
      result = -2 ;
      }
    }
  else
    {
    Alert("scan %s not found as barcode",scan) ;
    result = -1 ;
    }

  return result ;
  }

@ Proto.
@<Prototypes@>+=
int item_add(char *raw_scan, char *add_sku,int manual) ;

@* Processing.
 
@ Setup.
@<Functions@>+=
void
setup(void)
  {
  thin_clear(DARK_GRAY) ;
  thin_serial(0,"/dev/ttyACM0",9600,'N',8,1,13) ;
  }

@ Proto.
@<Prototypes@>+=
void setup(void) ;

@ Loop.
@<Functions@>+=
void
loop(void)
  {
  int fd ;
  int n ;
  fd_set rfds ;
  struct timeval tv ;

  fd = net_attach() ;

  FD_ZERO(&rfds) ;
  FD_SET(fd,&rfds) ;
  n = fd + 1 ;

  tv.tv_sec  =      0 ;
  tv.tv_usec = 100000 ;

  n = select(n,&rfds,NULL,NULL,&tv) ;
  
  if(n>0)
    {
    if(FD_ISSET(fd,&rfds))
      {
      int err ;
      char c ;

      err = read(fd,&c,1) ;

      if(err==1)
        {
        last_response = time(NULL) ;
        if(c==EOL)
          {
          handle(msg) ;
          m = 0 ;
          msg[m  ] = '\0' ;
          machine() ;
          }
        else if(c=='\n')
          {
          // discard
          }
        else
          {
          if(m < (MSG_N-1))
            {
            msg[m++] = c ;
            msg[m  ] = '\0' ;
            }
          else
            Alert("overflow character %x",c) ;
          }
        }
      if(err<=0)
        {
        Alert("read error %d",err) ;
        net_detach() ;
        }
      }
    }
  else if(n==0)
    {
    time_t now = time(NULL) ;

    if((now-last_response)>COMM_TIMEOUT)
      {
      Alert("timeout") ;
      net_detach() ;
      }
    else
      machine() ;
    }
  else
    {
    Alert("select error %d",n) ;
    net_detach() ;
    }
  }

@ Proto.
@<Prototypes@>+=
void loop(void) ;

@ Last response.
@<Globals@>+=
time_t last_response ;

@ End of Line, communication timeout
@<Defines@>+=
#define EOL '\r' 
#define COMM_TIMEOUT (300)

@* Thin.

@ Send.
@<Functions@>+=
void thin_send(char *msg)
   {
   int display ;
   int len, sent ;

//Trace("out [%s]",msg) ;

   len = strlen(msg) ;
   
   display = net_attach() ;
   if(display)
      {
      sent = write(display,msg,len) ;
//Inform("len %d sent %d",len,sent) ;
      if(sent!=len)
         {
         Alert("display write fails %d",sent) ;
         net_detach() ;
         }
      }
   else
     Alert("display could not be opened") ;
   }

@ Proto.
@<Prototypes@>+=
void thin_send(char *msg) ;

@ Colors
@<Defines@>+=
#define DARK_GRAY 0x40,0x40,0x40
#define GRAY      0x80,0x80,0x80
#define LIGHT_GRAY 0xC0,0xC0,0xC0
#define LIGHTER_GRAY 0xD0,0xD0,0xD0
#define WHITE     0xFF,0xFF,0xFF
#define RED       0xFF,0x00,0x00
#define GREEN     0x00,0xFF,0x00
#define DARK_GREEN 0x00,0x40,0x00
#define YELLOW    0xFF,0xFF,0x00
#define BROWN     0x99,0x66,0x33
#define AMBER     0xe6,0x5C,0x00
#define DARK_BLUE 0x00,0x00,0xC0
#define BLUE      0x40,0x40,0xC0
#define LIGHT_BLUE 0x80,0x80,0xFF
#define BLACK     0x00,0x00,0x00
#define MED_GREEN 0x28,0xBF,0x24
#define ORANGE    0xCC,0x7A,0x00

@ Clear screen.
@<Functions@>+=
void thin_clear(int r, int g, int b)
   {
   char msg[128+1] ;

   sprintf(msg,"C$00%02x%02x%02x\r",b,g,r) ;
   thin_send(msg) ;
   }

@ Proto.
@<Prototypes@>+=
void thin_clear(int r, int g, int b) ;

@ Thin Button.
@<Functions@>+=
void
thin_button(int tag,
           int left, int top,
           int width, int height,
           int size,char *text)
  {
  char msg[128+1] ;

  sprintf(msg,"B%d|%d|%d|%d|%d|%d|%s\r",
          tag,left,top,width,height,size,text) ;
  thin_send(msg) ;
  }

@ Proto.
@<Prototypes@>+=
void thin_button(int tag, int left, int top, int width, int height, 
                 int size, char*text) ;

@ Thin Entry.
@<Functions@>+=
void
thin_entry(int tag,
           int left, int top,
           int width, int height,
           int size)
  {
  char msg[128+1] ;

  sprintf(msg,"E%d|%d|%d|%d|%d|%d\r",
          tag,left,top,width,height,size) ;
  thin_send(msg) ;
  }

@ Proto.
@<Prototypes@>+=
void thin_entry(int tag, int left, int top, int width, int height, int size) ;

@ Thin Focus.
@<Functions@>+=
void
thin_focus(int tag)
  {
  char msg[128+1] ;

  sprintf(msg,"Y%d\r", tag) ;

  thin_send(msg) ;
  }

@ Proto.
@<Prototypes@>+=
void thin_focus(int tag) ;

@ Thin Text
@<Functions@>+=
void thin_text(int tag,
               int left, int top,
               int size,
               char *text,
               int r, int g, int b,
               int width )
   {
   char msg[128+1] ;

   sprintf(msg,"T%d|%d|%d|%d|%s|$00%02x%02x%02x|%d\r",
           tag,left,top,size,text,b,g,r,width) ;
   thin_send(msg) ;
   }

@ Proto.
@<Prototypes@>+=
void thin_text(int tag, int left, int top, int size,
               char *text, int r, int g, int b,
               int width ) ;

@ Thin Rect.
@<Functions@>+=
void thin_rect(int tag,
               int left, int top,
               int wide, int high,
               int r, int g, int b,
               int thick)
   {
   char msg[128+1] ;

   sprintf(msg,"R%d|%d|%d|%d|%d|$00%02x%02x%02x|%d|0\r",
           tag,left,top,wide,high,b,g,r,thick) ;
   thin_send(msg) ;
   }

@ Proto.
@<Prototypes@>+=
void thin_rect(int tag,
               int left, int top,
               int wide, int high,
               int r, int g, int b,
               int thick) ;

@ Thin Serial.
@<Functions@>+=
void 
thin_serial(int tag, 
            char *dev, 
            int baud, char parity, int databits, int stopbits,
            int endchar) 
  {
  char msg[128+1] ;

  sprintf(msg,"S%d|%s|%d|%c|%d|%d|%d\r",
          tag,dev,baud,parity,databits,stopbits,endchar) ;
  thin_send(msg) ;
  }

@ Proto.
@<Prototypes@>+=
void
thin_serial(int tag, 
            char *dev, 
            int baud, char parity, int databits, int stopbits,
            int endchar) ;

@ Thin Xmit.
@<Functions@>+=
void
thin_xmit(int tag, char *text)
  {
  char msg[128+1] ;

  sprintf(msg,"X%d|%s\r",
          tag,text) ;
  thin_send(msg) ;
  }

@ Proto.
@<Prototypes@>+=  
void
thin_xmit(int tag, char *text) ;

@* Scan.

@ Scan enable.
@<Functions@>+=
void
scan_enable(void)
  {
  thin_xmit(0,"45") ;
  }

@ Proto.
@<Prototypes@>+=
void scan_enable(void) ;

@ Scan disable
@<Functions@>+=
void
scan_disable(void)
  {
  thin_xmit(0,"44") ;
  }

@ Proto.
@<Prototypes@>+=
void scan_disable(void) ;

@ Scan Error.
@<Functions@>+=
void
scan_error(void)
  {
  thin_xmit(0,"46") ;
  }

@ Proto.
@<Prototypes@>+=
void scan_error(void) ;

@ Scan Beep.
@<Functions@>+=
void
scan_beep(void)
  {
  thin_xmit(0,"01") ;
  }

@ Proto.
@<Prototypes@>+=
void scan_beep(void) ;

@* Network Connection.
A global holds the handle to the port.  It is initialized to
an illegal handle.
@<Globals@>+=
int net = -1 ;


@ The function |net_attach()| 
opens the connection to the remote socket if it is not
already open.
This function sleeps and retries if the port cannot be opened.
This function should be called every time the port is about to be used.
@<Functions@>+=
int net_attach(void) 
   {
   extern int errno ;

   while(net<0)
      {
      net = net_open(net_ip,net_port) ;
   
      if(net<0)
         {
         Alert("Failed to open %s:%d",net_ip,net_port) ;
         evt_start(stationName) ;
         sleep(10) ;
         }
      else 
         {
         Trace("opened %s:%d handle %d",net_ip,net_port,net) ;
         evt_stop(stationName) ;
         sleep(1) ;
         state = -1 ;
         setup() ;
         }
      }
   return net ;
   }

@ A second function closes the port and resets the handle 
to an illegal value.  This is called in the event of an error which
indicates a probable connection loss.
This will trigger a reconnection on the next |net_attach()| call.
@<Functions@>+=
void net_detach(void)
   {
   if(net>=0)
      close(net) ;
   net = -1 ;
   }

@ Proto.
@<Prototypes@>+=
void net_detach(void) ;

@* Index.

